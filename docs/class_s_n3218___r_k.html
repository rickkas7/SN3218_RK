<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SN3218_RK: SN3218_RK Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SN3218_RK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">SN3218_RK Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class for interfacing with a SN3218 LED PWM controller.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_n3218___r_k_8h_source.html">SN3218_RK.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1ea52cb55f2bb973199e8f1f260fd2b0" id="r_a1ea52cb55f2bb973199e8f1f260fd2b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ea52cb55f2bb973199e8f1f260fd2b0">SN3218_RK</a> (uint8_t <a class="el" href="#a5c2e08d9dccdc5c6c4332b885fa37e4a">i2cAddress</a>=<a class="el" href="#adf68896c92cccafee5a67a950bc5fb31">DEFAULT_I2C_ADDRESS</a>)</td></tr>
<tr class="memdesc:a1ea52cb55f2bb973199e8f1f260fd2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for an instance of the class.  <br /></td></tr>
<tr class="separator:a1ea52cb55f2bb973199e8f1f260fd2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035cd6cedd57fc81b756b9ee2847d905" id="r_a035cd6cedd57fc81b756b9ee2847d905"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a035cd6cedd57fc81b756b9ee2847d905">begin</a> ()</td></tr>
<tr class="memdesc:a035cd6cedd57fc81b756b9ee2847d905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin I2C operation.  <br /></td></tr>
<tr class="separator:a035cd6cedd57fc81b756b9ee2847d905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7dc2b2a45e13ba4799ad2c2fc8451f9" id="r_aa7dc2b2a45e13ba4799ad2c2fc8451f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7dc2b2a45e13ba4799ad2c2fc8451f9">setPWM</a> (uint8_t channel, uint8_t value)</td></tr>
<tr class="memdesc:aa7dc2b2a45e13ba4799ad2c2fc8451f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the PWM value for a given channel.  <br /></td></tr>
<tr class="separator:aa7dc2b2a45e13ba4799ad2c2fc8451f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7199b676642971b4c97014de997cda7e" id="r_a7199b676642971b4c97014de997cda7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7199b676642971b4c97014de997cda7e">ledOn</a> (uint8_t channel)</td></tr>
<tr class="memdesc:a7199b676642971b4c97014de997cda7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on a single LED.  <br /></td></tr>
<tr class="separator:a7199b676642971b4c97014de997cda7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30957aa6df71c230d1e138260243f29e" id="r_a30957aa6df71c230d1e138260243f29e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30957aa6df71c230d1e138260243f29e">ledOff</a> (uint8_t channel)</td></tr>
<tr class="memdesc:a30957aa6df71c230d1e138260243f29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns off single LED.  <br /></td></tr>
<tr class="separator:a30957aa6df71c230d1e138260243f29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6b8930dc46e8c6f08ff9fcf4584b30" id="r_a3d6b8930dc46e8c6f08ff9fcf4584b30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d6b8930dc46e8c6f08ff9fcf4584b30">ledToggle</a> (uint8_t channel)</td></tr>
<tr class="memdesc:a3d6b8930dc46e8c6f08ff9fcf4584b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles the state of an LED on or off, opposite of what it previously was.  <br /></td></tr>
<tr class="separator:a3d6b8930dc46e8c6f08ff9fcf4584b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2647d3b5fdd50e1a446475c270c49f" id="r_a4a2647d3b5fdd50e1a446475c270c49f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a2647d3b5fdd50e1a446475c270c49f">ledState</a> (uint8_t channel) const</td></tr>
<tr class="memdesc:a4a2647d3b5fdd50e1a446475c270c49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current state of the specifed LED channel.  <br /></td></tr>
<tr class="separator:a4a2647d3b5fdd50e1a446475c270c49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac083785d0bf510957368d317af5dcf94" id="r_ac083785d0bf510957368d317af5dcf94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac083785d0bf510957368d317af5dcf94">ledControl</a> (uint32_t andMask, uint32_t orMask)</td></tr>
<tr class="memdesc:ac083785d0bf510957368d317af5dcf94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on or off multiple LEDs using a bitmask.  <br /></td></tr>
<tr class="separator:ac083785d0bf510957368d317af5dcf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0e34310787266859411622940e552d" id="r_a8c0e34310787266859411622940e552d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c0e34310787266859411622940e552d">update</a> ()</td></tr>
<tr class="memdesc:a8c0e34310787266859411622940e552d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update registers from temporary registers.  <br /></td></tr>
<tr class="separator:a8c0e34310787266859411622940e552d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb5b35f081c648cdec4e225fe6a4129" id="r_acfb5b35f081c648cdec4e225fe6a4129"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfb5b35f081c648cdec4e225fe6a4129">reset</a> ()</td></tr>
<tr class="memdesc:acfb5b35f081c648cdec4e225fe6a4129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the chip to default values.  <br /></td></tr>
<tr class="separator:acfb5b35f081c648cdec4e225fe6a4129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263712c9d53f1ad09a780234c5ec3f4a" id="r_a263712c9d53f1ad09a780234c5ec3f4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a263712c9d53f1ad09a780234c5ec3f4a">shutdown</a> ()</td></tr>
<tr class="memdesc:a263712c9d53f1ad09a780234c5ec3f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device in software shutdown mode.  <br /></td></tr>
<tr class="separator:a263712c9d53f1ad09a780234c5ec3f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27b037e967d978c73ea5c8a8590cfe1" id="r_ae27b037e967d978c73ea5c8a8590cfe1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae27b037e967d978c73ea5c8a8590cfe1">wake</a> ()</td></tr>
<tr class="memdesc:ae27b037e967d978c73ea5c8a8590cfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake the device from shutdown mode and resume normal operation.  <br /></td></tr>
<tr class="separator:ae27b037e967d978c73ea5c8a8590cfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6736c3ceead9cd1d849befd6febffce3" id="r_a6736c3ceead9cd1d849befd6febffce3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6736c3ceead9cd1d849befd6febffce3">writeRegister</a> (uint8_t reg, uint8_t value)</td></tr>
<tr class="memdesc:a6736c3ceead9cd1d849befd6febffce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single register value.  <br /></td></tr>
<tr class="separator:a6736c3ceead9cd1d849befd6febffce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d261bdf6eb76e20636b4430040f3c34" id="r_a1d261bdf6eb76e20636b4430040f3c34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d261bdf6eb76e20636b4430040f3c34">writeMultipleRegisters</a> (uint8_t reg, const uint8_t *values, size_t numValues)</td></tr>
<tr class="memdesc:a1d261bdf6eb76e20636b4430040f3c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write multiple sequential registers.  <br /></td></tr>
<tr class="separator:a1d261bdf6eb76e20636b4430040f3c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a959fa05b59417adeabd9468babd087c2" id="r_a959fa05b59417adeabd9468babd087c2"><td class="memItemLeft" align="right" valign="top"><a id="a959fa05b59417adeabd9468babd087c2" name="a959fa05b59417adeabd9468babd087c2"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>REG_SHUTDOWN</b> = 0x00</td></tr>
<tr class="memdesc:a959fa05b59417adeabd9468babd087c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down the chip. <br /></td></tr>
<tr class="separator:a959fa05b59417adeabd9468babd087c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3898878e4f851597eb5352bf12a360" id="r_a4c3898878e4f851597eb5352bf12a360"><td class="memItemLeft" align="right" valign="top"><a id="a4c3898878e4f851597eb5352bf12a360" name="a4c3898878e4f851597eb5352bf12a360"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>REG_PWM_FIRST</b> = 0x01</td></tr>
<tr class="memdesc:a4c3898878e4f851597eb5352bf12a360"><td class="mdescLeft">&#160;</td><td class="mdescRight">First of the 18 PWM registers. <br /></td></tr>
<tr class="separator:a4c3898878e4f851597eb5352bf12a360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91464675369305830161b2bc7205b8bb" id="r_a91464675369305830161b2bc7205b8bb"><td class="memItemLeft" align="right" valign="top"><a id="a91464675369305830161b2bc7205b8bb" name="a91464675369305830161b2bc7205b8bb"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>REG_LED_CONTROL1</b> = 0x13</td></tr>
<tr class="memdesc:a91464675369305830161b2bc7205b8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">LED on/off control register 1. <br /></td></tr>
<tr class="separator:a91464675369305830161b2bc7205b8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7f8e3d645417eae9f30f5d26a06e22" id="r_afa7f8e3d645417eae9f30f5d26a06e22"><td class="memItemLeft" align="right" valign="top"><a id="afa7f8e3d645417eae9f30f5d26a06e22" name="afa7f8e3d645417eae9f30f5d26a06e22"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>REG_LED_CONTROL2</b> = 0x14</td></tr>
<tr class="memdesc:afa7f8e3d645417eae9f30f5d26a06e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">LED on/off control register 2. <br /></td></tr>
<tr class="separator:afa7f8e3d645417eae9f30f5d26a06e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27db2c886ae9066455cdd8e6ec10ab0c" id="r_a27db2c886ae9066455cdd8e6ec10ab0c"><td class="memItemLeft" align="right" valign="top"><a id="a27db2c886ae9066455cdd8e6ec10ab0c" name="a27db2c886ae9066455cdd8e6ec10ab0c"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>REG_LED_CONTROL3</b> = 0x15</td></tr>
<tr class="memdesc:a27db2c886ae9066455cdd8e6ec10ab0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LED on/off control register 3. <br /></td></tr>
<tr class="separator:a27db2c886ae9066455cdd8e6ec10ab0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3f54ce7ebaa9446a1d62c5496e450e" id="r_abd3f54ce7ebaa9446a1d62c5496e450e"><td class="memItemLeft" align="right" valign="top"><a id="abd3f54ce7ebaa9446a1d62c5496e450e" name="abd3f54ce7ebaa9446a1d62c5496e450e"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>REG_UPDATE</b> = 0x16</td></tr>
<tr class="memdesc:abd3f54ce7ebaa9446a1d62c5496e450e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the outputs to match the registers. <br /></td></tr>
<tr class="separator:abd3f54ce7ebaa9446a1d62c5496e450e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c0f9c2c4fb7b062660b4c487311af5" id="r_a17c0f9c2c4fb7b062660b4c487311af5"><td class="memItemLeft" align="right" valign="top"><a id="a17c0f9c2c4fb7b062660b4c487311af5" name="a17c0f9c2c4fb7b062660b4c487311af5"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>REG_RESET</b> = 0x17</td></tr>
<tr class="memdesc:a17c0f9c2c4fb7b062660b4c487311af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software reset the chip. <br /></td></tr>
<tr class="separator:a17c0f9c2c4fb7b062660b4c487311af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf68896c92cccafee5a67a950bc5fb31" id="r_adf68896c92cccafee5a67a950bc5fb31"><td class="memItemLeft" align="right" valign="top"><a id="adf68896c92cccafee5a67a950bc5fb31" name="adf68896c92cccafee5a67a950bc5fb31"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>DEFAULT_I2C_ADDRESS</b> = 0x54</td></tr>
<tr class="memdesc:adf68896c92cccafee5a67a950bc5fb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">0b1010100 <br /></td></tr>
<tr class="separator:adf68896c92cccafee5a67a950bc5fb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae122380a156c8d0b4d998adf1137d6fe" id="r_ae122380a156c8d0b4d998adf1137d6fe"><td class="memItemLeft" align="right" valign="top"><a id="ae122380a156c8d0b4d998adf1137d6fe" name="ae122380a156c8d0b4d998adf1137d6fe"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_LAST</b> = 17</td></tr>
<tr class="memdesc:ae122380a156c8d0b4d998adf1137d6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">0-based! Used for bounds checking channel values <br /></td></tr>
<tr class="separator:ae122380a156c8d0b4d998adf1137d6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5c2e08d9dccdc5c6c4332b885fa37e4a" id="r_a5c2e08d9dccdc5c6c4332b885fa37e4a"><td class="memItemLeft" align="right" valign="top"><a id="a5c2e08d9dccdc5c6c4332b885fa37e4a" name="a5c2e08d9dccdc5c6c4332b885fa37e4a"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>i2cAddress</b> = <a class="el" href="#adf68896c92cccafee5a67a950bc5fb31">DEFAULT_I2C_ADDRESS</a></td></tr>
<tr class="memdesc:a5c2e08d9dccdc5c6c4332b885fa37e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C address for the chip. <br /></td></tr>
<tr class="separator:a5c2e08d9dccdc5c6c4332b885fa37e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526f954e1c377d4ec103da14f26f3b15" id="r_a526f954e1c377d4ec103da14f26f3b15"><td class="memItemLeft" align="right" valign="top"><a id="a526f954e1c377d4ec103da14f26f3b15" name="a526f954e1c377d4ec103da14f26f3b15"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>currentLedState</b> = 0</td></tr>
<tr class="memdesc:a526f954e1c377d4ec103da14f26f3b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current LED on/off states. <br /></td></tr>
<tr class="separator:a526f954e1c377d4ec103da14f26f3b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d304263b5c6ef7a21ff9e67e1787f26" id="r_a9d304263b5c6ef7a21ff9e67e1787f26"><td class="memItemLeft" align="right" valign="top"><a id="a9d304263b5c6ef7a21ff9e67e1787f26" name="a9d304263b5c6ef7a21ff9e67e1787f26"></a>
TwoWire &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>wire</b> = Wire</td></tr>
<tr class="memdesc:a9d304263b5c6ef7a21ff9e67e1787f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C port to use. <br /></td></tr>
<tr class="separator:a9d304263b5c6ef7a21ff9e67e1787f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for interfacing with a SN3218 LED PWM controller. </p>
<p>Because the address of the SN3218 is not configurable you will typically only have one instance of this class as a global variable. It's not explicitly a singleton because you could have more than one instance if you have multiple I2C busses or an I2C MUX.</p>
<p>Note that there should be an instance of this class for each physical chip. Because the chip does not support reading registers, the current LED on and off state is stored as a class variable so you can easily change just a single LED. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1ea52cb55f2bb973199e8f1f260fd2b0" name="a1ea52cb55f2bb973199e8f1f260fd2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea52cb55f2bb973199e8f1f260fd2b0">&#9670;&#160;</a></span>SN3218_RK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SN3218_RK::SN3218_RK </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>i2cAddress</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#adf68896c92cccafee5a67a950bc5fb31">DEFAULT_I2C_ADDRESS</a></span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for an instance of the class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2cAddress</td><td>I2C address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a035cd6cedd57fc81b756b9ee2847d905" name="a035cd6cedd57fc81b756b9ee2847d905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035cd6cedd57fc81b756b9ee2847d905">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SN3218_RK::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin I2C operation. </p>
<p>This just calls Wire.begin(), but is provided as a reminder that you need to do that. </p>

</div>
</div>
<a id="ac083785d0bf510957368d317af5dcf94" name="ac083785d0bf510957368d317af5dcf94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac083785d0bf510957368d317af5dcf94">&#9670;&#160;</a></span>ledControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SN3218_RK::ledControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>andMask</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>orMask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns on or off multiple LEDs using a bitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">andMask</td><td></td></tr>
    <tr><td class="paramname">orMask</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the I2C operation succeeded</dd></dl>
<p>This does not immediately affect the outputs; you must call <a class="el" href="#a8c0e34310787266859411622940e552d" title="Update registers from temporary registers.">update()</a> to do that after setting the PWM values or on/off state.</p>
<p>The mask is such that 0x00000001 is OUT1, 0x00000002 is OUT2, ... </p>

</div>
</div>
<a id="a30957aa6df71c230d1e138260243f29e" name="a30957aa6df71c230d1e138260243f29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30957aa6df71c230d1e138260243f29e">&#9670;&#160;</a></span>ledOff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SN3218_RK::ledOff </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>channel</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns off single LED. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>0 - 17 (note: this is zero-based not OUT1 - OUT18!) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the channel is valid and I2C operation succeeded</dd></dl>
<p>This does not immediately affect the outputs; you must call <a class="el" href="#a8c0e34310787266859411622940e552d" title="Update registers from temporary registers.">update()</a> to do that after setting the PWM values or on/off state. </p>

</div>
</div>
<a id="a7199b676642971b4c97014de997cda7e" name="a7199b676642971b4c97014de997cda7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7199b676642971b4c97014de997cda7e">&#9670;&#160;</a></span>ledOn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SN3218_RK::ledOn </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>channel</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns on a single LED. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>0 - 17 (note: this is zero-based not OUT1 - OUT18!) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the channel is valid and I2C operation succeeded</dd></dl>
<p>On and off are separate from the PWM setting. Turning the LED on uses the previously set PWM value. Note that the default PWM is 0, which effectively will prevent the output from turning on if not set.</p>
<p>This does not immediately affect the outputs; you must call <a class="el" href="#a8c0e34310787266859411622940e552d" title="Update registers from temporary registers.">update()</a> to do that after setting the PWM values or on/off state. </p>

</div>
</div>
<a id="a4a2647d3b5fdd50e1a446475c270c49f" name="a4a2647d3b5fdd50e1a446475c270c49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2647d3b5fdd50e1a446475c270c49f">&#9670;&#160;</a></span>ledState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SN3218_RK::ledState </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>channel</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current state of the specifed LED channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>0 - 17 (note: this is zero-based not OUT1 - OUT18!) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if LED is currently on, false if off (or channel is not valid) </dd></dl>

</div>
</div>
<a id="a3d6b8930dc46e8c6f08ff9fcf4584b30" name="a3d6b8930dc46e8c6f08ff9fcf4584b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6b8930dc46e8c6f08ff9fcf4584b30">&#9670;&#160;</a></span>ledToggle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SN3218_RK::ledToggle </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>channel</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggles the state of an LED on or off, opposite of what it previously was. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>0 - 17 (note: this is zero-based not OUT1 - OUT18!) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the channel is valid and I2C operation succeeded</dd></dl>
<p>This does not immediately affect the outputs; you must call <a class="el" href="#a8c0e34310787266859411622940e552d" title="Update registers from temporary registers.">update()</a> to do that after setting the PWM values or on/off state. </p>

</div>
</div>
<a id="acfb5b35f081c648cdec4e225fe6a4129" name="acfb5b35f081c648cdec4e225fe6a4129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb5b35f081c648cdec4e225fe6a4129">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SN3218_RK::reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the chip to default values. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the I2C operation succeeded </dd></dl>

</div>
</div>
<a id="aa7dc2b2a45e13ba4799ad2c2fc8451f9" name="aa7dc2b2a45e13ba4799ad2c2fc8451f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7dc2b2a45e13ba4799ad2c2fc8451f9">&#9670;&#160;</a></span>setPWM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SN3218_RK::setPWM </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the PWM value for a given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>0 - 17 (note: this is zero-based not OUT1 - OUT18!) </td></tr>
    <tr><td class="paramname">value</td><td>0-255 (0 is off, 255 is 100% on) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the channel is valid and I2C operation succeeded</dd></dl>
<p>The power-on default is 0, so you pretty much need to set it to another value to turn on an output pin.</p>
<p>There are on and off states separate from the PWM setting.</p>
<p>This does not immediately affect the outputs; you must call <a class="el" href="#a8c0e34310787266859411622940e552d" title="Update registers from temporary registers.">update()</a> to do that after setting the PWM values or on/off state. </p>

</div>
</div>
<a id="a263712c9d53f1ad09a780234c5ec3f4a" name="a263712c9d53f1ad09a780234c5ec3f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263712c9d53f1ad09a780234c5ec3f4a">&#9670;&#160;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SN3218_RK::shutdown </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the device in software shutdown mode. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the I2C operation succeeded </dd></dl>

</div>
</div>
<a id="a8c0e34310787266859411622940e552d" name="a8c0e34310787266859411622940e552d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0e34310787266859411622940e552d">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SN3218_RK::update </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update registers from temporary registers. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the I2C operation succeeded </dd></dl>

</div>
</div>
<a id="ae27b037e967d978c73ea5c8a8590cfe1" name="ae27b037e967d978c73ea5c8a8590cfe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27b037e967d978c73ea5c8a8590cfe1">&#9670;&#160;</a></span>wake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SN3218_RK::wake </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wake the device from shutdown mode and resume normal operation. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the I2C operation succeeded</dd></dl>
<p>This is required at boot to enable the outputs as the default is off! </p>

</div>
</div>
<a id="a1d261bdf6eb76e20636b4430040f3c34" name="a1d261bdf6eb76e20636b4430040f3c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d261bdf6eb76e20636b4430040f3c34">&#9670;&#160;</a></span>writeMultipleRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SN3218_RK::writeMultipleRegisters </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>reg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>values</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numValues</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write multiple sequential registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>First register to write to (see REG_ constants in this class) </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to an array of uint8_t values </td></tr>
    <tr><td class="paramname">numValues</td><td>Number of values to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the I2C operation succeeded</dd></dl>
<p>This chip does not support reading register values! </p>

</div>
</div>
<a id="a6736c3ceead9cd1d849befd6febffce3" name="a6736c3ceead9cd1d849befd6febffce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6736c3ceead9cd1d849befd6febffce3">&#9670;&#160;</a></span>writeRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SN3218_RK::writeRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>reg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single register value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Register to write to (see REG_ constants in this class) </td></tr>
    <tr><td class="paramname">value</td><td>Value to write (1 byte) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the I2C operation succeeded</dd></dl>
<p>This chip does not support reading register values! </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_s_n3218___r_k_8h_source.html">SN3218_RK.h</a></li>
<li>src/<b>SN3218_RK.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
